\section{Client API (market/client/)}
\label{Chapters/Background/Client-API}
The \texttt{Client API} fulfils requirement \textit{F10}. The primary purpose is to handle the intricacies of the simulation startup, provide  a single gateway responsible for receiving messages and routing them to the user code, and provide simple method calls that construct \texttt{JADE} messages from \texttt{Market Ontology} objects.

Following the principles outlined in \Cref{Chapters/Implementation/Overall-Principles}, an interface is defined in \\ \texttt{eugene.market.client.Session} that specifies the methods for sending   and extracting \texttt{Market Ontology} objects from \texttt{JADE} messages. The implementation is located in \\\texttt{eugene.market.client.impl.SessionImpl}, however no client code uses this class directly. In order to connect to a \texttt{Market Agent} defined by the current \texttt{Simulation}, the \texttt{Trader Agent} will obtain a \texttt{Behaviour} from \texttt{eugene.market.client.Sessions} factory that will establish the connection. The actual implementation is located in \texttt{eugene.market.client.impl.SessionInitiator}, in a private package. 

In order to establish a \texttt{Session}, the \texttt{Trader Agent} needs to provide an implementation of the \texttt{eugene.market.client.Application} interface, that will receive notifications of all messages that will be sent and received by the \texttt{Session}. If the \texttt{Trader Agent} requires several objects listening to messages, those can be routed using an implementation of \texttt{eugene.market.client.ProxyApplication}, obtained from \\\texttt{eugene.market.client.Applications} factory. \texttt{ProxyApplication} will route messages to other \texttt{Application} instances given to it (\texttt{Application} instances can be added or removed dynamically).

One use case, when the \texttt{Trader Agent} requires messages to be routed to several objects, is when there is a need to build the order book, as well as calculate statistics about the behaviour of the instrument traded. In the interest of separation of concerns, these two roles should be implemented by different classes, and indeed such separation is possible thanks to the \texttt{ProxyApplication}.

In the interest of code reuse, an instance of an \texttt{Application} that will build the order book can be obtained from the \texttt{Applications} factory. Th \texttt{proxy} pattern allows for ease of composing different \texttt{Application} instances to create complex dependency graphs: indeed an example is \texttt{eugene.market.client.TopOfBookApplication} that requires an instance of \texttt{OrderBook} that is updated from messages and exposes a simple API for tracking the last price at the top of either side of the book.

Last functionality worth mentioning is that \texttt{Session} tracks the status of orders submitted: user code can register an instance of \\ \texttt{eugene.market.client.OrderReferenceListener} to receive updates about a single order. Similarly to \texttt{Application}, order updates can be routed if more than one instance of \texttt{OrderReferenceListener} needs to be notified \\ (\texttt{eugene.market.client.OrderReferenceListenerProxy} that can be obtained from \texttt{eugene.market.client.OrderReferenceListeners} factory).